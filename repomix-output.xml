This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
process-pcb-traces/
  DsnTraceOperationsWrapper.ts
  findOrCreateViaPadstack.ts
  index.ts
convert-circuit-json-to-dsn-json.ts
convert-circuit-json-to-dsn-session.ts
convert-circuit-json-to-dsn-string.ts
process-components-and-pads.ts
process-nets.ts
process-plated-holes.ts
stringify-dsn-json.ts
stringify-dsn-session.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="process-pcb-traces/DsnTraceOperationsWrapper.ts">
import type { DsnPcb, DsnSession, Wire } from "lib/dsn-pcb/types"

export interface DsnTraceOperationsWrapper {
  getNextNetId(): string
  addWire(wire: Wire): void
  getLibrary(): DsnPcb["library"]
  getStructure(): DsnPcb["structure"] | null
}

/**
 * This operations wrapper allows you to operate on either DSN PCB or DSN
 * Session objects, increasing code reusability when working with traces.
 *
 * Please add more methods to this as you need them!
 */
export const getDsnTraceOperationsWrapper = (
  dsnObj: DsnPcb | DsnSession,
): DsnTraceOperationsWrapper => {
  if (dsnObj.is_dsn_pcb) {
    return {
      getNextNetId: () => `Net-${dsnObj.network.nets.length + 1}`,
      addWire: (wire: Wire) => {
        dsnObj.wiring.wires.push(wire as any)
      },
      getStructure: () => dsnObj.structure,
      getLibrary: () => dsnObj.library,
    }
  }

  if (dsnObj.is_dsn_session) {
    return {
      getNextNetId: () => `Net-${dsnObj.routes.network_out.nets.length + 1}`,
      getLibrary: () => dsnObj.routes.library_out!,
      getStructure: () => null,
      addWire: (wire: Wire) => {
        let net = dsnObj.routes.network_out.nets.find(
          (net) => net.name === wire.net,
        )
        if (!net) {
          net = {
            name: wire.net!,
            wires: [],
          }
          dsnObj.routes.network_out.nets.push(net)
        }
        net.wires.push(wire)
      },
    }
  }

  throw new Error("Invalid DSN object")
}
</file>

<file path="process-pcb-traces/findOrCreateViaPadstack.ts">
import type { DsnPcb, Padstack } from "lib/dsn-pcb/types"
import type { DsnTraceOperationsWrapper } from "./DsnTraceOperationsWrapper"

export function findOrCreateViaPadstack(
  pcb: DsnTraceOperationsWrapper,
  outerDiameter: number,
  holeDiameter: number,
): string {
  const viaName = `Via[0-1]_${outerDiameter}:${holeDiameter}_um`

  const library = pcb.getLibrary()

  // Check if padstack already exists
  const existingPadstack = library.padstacks.find((p) => p.name === viaName)

  if (existingPadstack) {
    return viaName
  }

  // Create new padstack for via
  const viaPadstack: Padstack = {
    name: viaName,
    attach: "off",
    shapes: [
      {
        shapeType: "circle",
        layer: "F.Cu",
        diameter: outerDiameter,
      },
      {
        shapeType: "circle",
        layer: "B.Cu",
        diameter: outerDiameter,
      },
    ],
    hole: {
      shape: "circle",
      diameter: holeDiameter,
    },
  }

  library.padstacks.push(viaPadstack)
  return viaName
}
</file>

<file path="process-pcb-traces/index.ts">
import type {
  AnyCircuitElement,
  LayerRef,
  PcbTrace,
  PcbTraceRoutePoint,
} from "circuit-json"
import type { DsnPcb, DsnSession } from "../../types"
import Debug from "debug"
import { findOrCreateViaPadstack } from "./findOrCreateViaPadstack"
import { getDsnTraceOperationsWrapper } from "./DsnTraceOperationsWrapper"
import { su } from "@tscircuit/soup-util"
import { getCombinedSourcePortName } from "lib/utils/get-combined-source-port-name"

const debug = Debug("dsn-converter:processPcbTraces")

const DEFAULT_VIA_DIAMETER = 600 // μm
const DEFAULT_VIA_HOLE = 300 // μm

interface Wire {
  path: {
    layer: string
    width: number
    coordinates: number[]
  }
  net: string
  type: string
}

function createWire(opts: {
  layer: LayerRef
  widthMm: number
  netName: string
}): Wire {
  return {
    path: {
      layer: opts.layer === "top" ? "F.Cu" : "B.Cu",
      width: opts.widthMm,
      coordinates: [],
    },
    net: opts.netName,
    type: "route",
  }
}

export function processPcbTraces(
  circuitElements: AnyCircuitElement[],
  pcb: DsnPcb | DsnSession,
) {
  const dsnWrapper = getDsnTraceOperationsWrapper(pcb)
  const CJ_TO_DSN_SCALE = pcb.is_dsn_pcb ? 1000 : 10000

  for (const element of circuitElements) {
    if (element.type === "pcb_trace") {
      const pcbTrace = element
      const source_trace = su(circuitElements).source_trace.getWhere({
        source_trace_id: pcbTrace.source_trace_id,
      })
      const source_net =
        source_trace &&
        su(circuitElements)
          .source_net.list()
          .find((n) =>
            source_trace.connected_source_net_ids.includes(n.source_net_id),
          )
      debug("PCB TRACE\n----------\n", pcbTrace)
      const sourceTraceConnectedPortIds = getCombinedSourcePortName(
        circuitElements,
        source_trace?.connected_source_port_ids || [],
      )
      const netName =
        source_net?.name ||
        `${pcbTrace.source_trace_id}--${sourceTraceConnectedPortIds}` ||
        dsnWrapper.getNextNetId()

      let currentLayer = ""
      let currentWire: Wire | null = null

      // Process each point in the route
      for (let i = 0; i < pcbTrace.route.length; i++) {
        const point = pcbTrace.route[i] as PcbTraceRoutePoint
        debug("POINT\n------\n", point)

        if (point.route_type === "wire") {
          // If layer changed or this is the first point, start a new wire
          const hasLayerChanged = currentLayer && point.layer !== currentLayer
          const isFirstPoint = !currentWire

          if (isFirstPoint) {
            // Start new wire on new layer
            currentWire = createWire({
              layer: point.layer,
              widthMm: point.width * CJ_TO_DSN_SCALE,
              netName,
            })

            dsnWrapper.addWire(currentWire)
            currentLayer = point.layer
          }

          if (currentWire && !hasLayerChanged) {
            // Add coordinates to current wire
            currentWire.path.coordinates.push(point.x * CJ_TO_DSN_SCALE)
            currentWire.path.coordinates.push(point.y * CJ_TO_DSN_SCALE)
            continue
          }

          if (hasLayerChanged) {
            const prevPoint = pcbTrace.route[i - 1]
            const viaPadstackName = findOrCreateViaPadstack(
              dsnWrapper,
              DEFAULT_VIA_DIAMETER,
              DEFAULT_VIA_HOLE,
            )

            // Add via reference to structure if not already there
            if (dsnWrapper.getStructure() && !dsnWrapper.getStructure()?.via) {
              dsnWrapper.getStructure()!.via = viaPadstackName
            }

            // Create wire segment for via placement
            dsnWrapper.addWire({
              path: {
                layer: currentLayer === "top" ? "F.Cu" : "B.Cu",
                width: DEFAULT_VIA_DIAMETER,
                coordinates: [
                  prevPoint.x * CJ_TO_DSN_SCALE,
                  prevPoint.y * CJ_TO_DSN_SCALE,
                ],
              },
              net: netName,
              type: "via",
            })
          }
          continue
        }

        if (point.route_type === "via") {
          debug("VIA\n----\n", point)

          // End current wire
          if (currentWire) {
            currentWire.path.coordinates.push(point.x * CJ_TO_DSN_SCALE)
            currentWire.path.coordinates.push(point.y * CJ_TO_DSN_SCALE)
            currentWire = null
          }

          // Handle explicit via points
          const viaPadstackName = findOrCreateViaPadstack(
            dsnWrapper,
            DEFAULT_VIA_DIAMETER,
            DEFAULT_VIA_HOLE,
          )

          debug("VIA PADSTACK NAME:", viaPadstackName)

          // Add via reference to structure if not already there
          if (dsnWrapper.getStructure() && !dsnWrapper.getStructure()?.via) {
            dsnWrapper.getStructure()!.via = viaPadstackName
          }

          // Create wire segment for via placement
          dsnWrapper.addWire({
            path: {
              layer: point.from_layer === "top" ? "F.Cu" : "B.Cu",
              width: DEFAULT_VIA_DIAMETER,
              coordinates: [
                point.x * CJ_TO_DSN_SCALE,
                point.y * CJ_TO_DSN_SCALE,
              ],
            },
            net: netName,
            type: "via",
          })

          currentLayer = point.to_layer
          currentWire = null // Start fresh wire after via
        }
      }
    }
  }
  debug(
    "PCB WIRING/NETWORK_OUT AT END",
    JSON.stringify(
      pcb.is_dsn_pcb ? pcb.wiring : pcb.routes.network_out.nets,
      null,
      2,
    ),
  )
}
</file>

<file path="convert-circuit-json-to-dsn-json.ts">
import type { AnyCircuitElement } from "circuit-json"
import type { DsnPcb, Padstack, ComponentGroup } from "../types"
import { processComponentsAndPads } from "./process-components-and-pads"
import { processNets } from "./process-nets"
import { processPcbTraces } from "./process-pcb-traces"
import { processPlatedHoles } from "./process-plated-holes"
import { generateLayers } from "lib/utils/generate-layers"

export function convertCircuitJsonToDsnJson(
  circuitElements: AnyCircuitElement[],
  options: {
    traceClearance?: number
  } = {},
): DsnPcb {
  // Find the PCB board element
  const pcbBoard = circuitElements.find(
    (element) => element.type === "pcb_board",
  ) as AnyCircuitElement & {
    width: number
    height: number
    center: { x: number; y: number }
    num_layers?: number
  }

  const numLayers = pcbBoard?.num_layers ?? 2
  const layers = generateLayers(numLayers)

  const pcb: DsnPcb = {
    is_dsn_pcb: true,
    filename: "",
    parser: {
      string_quote: "",
      host_version: "",
      space_in_quoted_tokens: "",
      host_cad: "",
    },
    resolution: {
      unit: "um",
      value: 10,
    },
    unit: "um",
    structure: {
      layers,
      boundary: {
        path: {
          layer: "pcb",
          width: 0,
          coordinates: calculateBoardBoundary(pcbBoard),
        },
      },
      via: "Via[0-1]_600:300_um",
      rule: {
        // Default clearance having fallback value
        clearances: [
          {
            value: options.traceClearance ?? 150,
          },
          {
            value: 50,
            type: "smd_smd",
          },
        ],
        width: 200,
      },
    },
    placement: {
      components: [],
    },
    library: {
      images: [],
      padstacks: [
        {
          name: "Via[0-1]_600:300_um",
          shapes: [
            {
              shapeType: "circle",
              layer: "F.Cu",
              diameter: 600,
            },
            {
              shapeType: "circle",
              layer: "B.Cu",
              diameter: 600,
            },
          ],
          attach: "off",
        },
      ],
    },
    network: {
      nets: [],
      classes: [
        {
          name: "kicad_default",
          description: "",
          net_names: [],
          circuit: {
            use_via: "Via[0-1]_600:300_um",
          },
          rule: {
            // Actual value being used in the dsn for the specific network class
            clearances: [
              {
                value: options.traceClearance ?? 150, // standard value
              },
            ],
            width: 150, // trace width used in freerouting
          },
        },
      ],
    },
    wiring: {
      wires: [],
    },
  }

  const componentGroups = groupComponents(circuitElements)
  processComponentsAndPads(componentGroups, circuitElements, pcb)
  processPlatedHoles(componentGroups, circuitElements, pcb)
  processNets(circuitElements, pcb)
  processPcbTraces(circuitElements, pcb)
  return pcb
}

function calculateBoardBoundary(pcbBoard: {
  width: number
  height: number
  center: { x: number; y: number }
}): number[] {
  // default to 100mm x 100mm if not provided
  const width = pcbBoard?.width ?? 100
  const height = pcbBoard?.height ?? 100
  const x = pcbBoard?.center?.x ?? 0
  const y = pcbBoard?.center?.y ?? 0

  // Convert dimensions from mm to μm and calculate corners
  const halfWidth = (width * 1000) / 2
  const halfHeight = (height * 1000) / 2
  const centerX = x * 1000
  const centerY = y * 1000

  // Return coordinates for a rectangular boundary path
  // Format: [x1, y1, x2, y2, x3, y3, x4, y4, x1, y1] to close the path
  return [
    centerX - halfWidth,
    centerY - halfHeight, // Top left
    centerX + halfWidth,
    centerY - halfHeight, // Top right
    centerX + halfWidth,
    centerY + halfHeight, // Bottom right
    centerX - halfWidth,
    centerY + halfHeight, // Bottom left
    centerX - halfWidth,
    centerY - halfHeight, // Back to top left to close the path
  ]
}

function groupComponents(
  circuitElements: AnyCircuitElement[],
): ComponentGroup[] {
  const componentMap = new Map<string, ComponentGroup>()

  for (const element of circuitElements) {
    if (element.type === "pcb_smtpad" || element.type === "pcb_plated_hole") {
      const componentId = element.pcb_component_id ?? ""

      if (!componentMap.has(componentId)) {
        componentMap.set(componentId, {
          pcb_component_id: componentId,
          pcb_smtpads: [],
          pcb_plated_holes: [],
        })
      }

      if (element.type === "pcb_smtpad") {
        componentMap.get(componentId)?.pcb_smtpads.push(element)
      } else if (element.type === "pcb_plated_hole") {
        componentMap.get(componentId)?.pcb_plated_holes.push(element)
      }
    }
  }

  return Array.from(componentMap.values())
}
</file>

<file path="convert-circuit-json-to-dsn-session.ts">
import type { AnyCircuitElement } from "circuit-json"
import type { DsnPcb, DsnSession } from "../types"
import { processPcbTraces } from "./process-pcb-traces"

export function convertCircuitJsonToDsnSession(
  dsnPcb: DsnPcb,
  circuitJson: AnyCircuitElement[],
): DsnSession {
  const session: DsnSession = {
    is_dsn_session: true,
    filename: dsnPcb.filename || "session",
    placement: {
      resolution: dsnPcb.resolution,
      components: dsnPcb.placement.components,
    },
    routes: {
      resolution: dsnPcb.resolution,
      parser: dsnPcb.parser,
      library_out: {
        images: [],
        padstacks: [],
      },
      network_out: {
        nets: [],
      },
    },
  }

  processPcbTraces(circuitJson, session)

  return session
}
</file>

<file path="convert-circuit-json-to-dsn-string.ts">
import type { AnyCircuitElement } from "circuit-json"
import { convertCircuitJsonToDsnJson } from "./convert-circuit-json-to-dsn-json"
import { stringifyDsnJson } from "./stringify-dsn-json"

export const convertCircuitJsonToDsnString = (
  circuitJson: AnyCircuitElement[],
  options: {
    traceClearance?: number
  } = {},
) => {
  const dsnJson = convertCircuitJsonToDsnJson(circuitJson, options)
  return stringifyDsnJson(dsnJson)
}
</file>

<file path="process-components-and-pads.ts">
import { su } from "@tscircuit/soup-util"
import type {
  AnyCircuitElement,
  PcbComponent,
  SourceComponentBase,
} from "circuit-json"
import { getComponentValue } from "lib/utils/get-component-value"
import { getFootprintName } from "lib/utils/get-footprint-name"
import { applyToPoint, scale } from "transformation-matrix"
import type { ComponentGroup, DsnPcb, Image, Pin } from "../types"
import { createAndAddPadstackFromPcbSmtPad } from "lib/utils/create-and-add-padstack-for-pcb-smtpad"
import { createPinForImage } from "lib/utils/create-pin-for-image"

const transformMmToUm = scale(1000)

export function processComponentsAndPads(
  componentGroups: ComponentGroup[],
  circuitElements: AnyCircuitElement[],
  pcb: DsnPcb,
) {
  const processedPadstacks = new Set<string>()
  const componentsByFootprint = new Map<
    string,
    Array<{
      componentName: string
      coordinates: { x: number; y: number }
      rotation: number
      value: string
      sourceComponent: SourceComponentBase | undefined
    }>
  >()

  // First pass: Group components by footprint
  for (const group of componentGroups) {
    const { pcb_component_id, pcb_smtpads } = group
    if (pcb_smtpads.length === 0) continue

    const pcbComponent = su(circuitElements)
      .pcb_component.list()
      .find((e) => e.pcb_component_id === pcb_component_id)
    const sourceComponent = su(circuitElements)
      .source_component.list()
      .find((e) => e.source_component_id === pcbComponent?.source_component_id)

    const footprintName = getFootprintName(sourceComponent!, pcbComponent!)
    const componentName = sourceComponent?.name || "Unknown"
    const circuitSpaceCoordinates = applyToPoint(
      transformMmToUm,
      pcbComponent!.center,
    )

    if (!componentsByFootprint.has(footprintName)) {
      componentsByFootprint.set(footprintName, [])
    }

    componentsByFootprint.get(footprintName)?.push({
      componentName,
      coordinates: circuitSpaceCoordinates,
      rotation: pcbComponent?.rotation || 0,
      value: getComponentValue(sourceComponent),
      sourceComponent,
    })
  }

  // Second pass: Process each footprint group
  for (const [footprintName, components] of componentsByFootprint) {
    // All are having the same footprint so getting the first one
    const firstComponent = components[0]
    const componentGroup = componentGroups.find((group) => {
      const pcbComponent = circuitElements.find(
        (e) =>
          e.type === "pcb_component" &&
          e.source_component_id ===
            firstComponent.sourceComponent?.source_component_id,
      ) as PcbComponent
      return (
        pcbComponent && group.pcb_component_id === pcbComponent.pcb_component_id
      )
    })

    if (!componentGroup) continue

    // Add padstacks for SMT pads
    for (const pad of componentGroup.pcb_smtpads) {
      createAndAddPadstackFromPcbSmtPad(pcb, pad, processedPadstacks)
    }

    // Add image once per footprint
    const image: Image = {
      name: footprintName,
      outlines: [],
      pins: componentGroup.pcb_smtpads
        .map((pad) => {
          const pcbComponent = circuitElements.find(
            (e) =>
              e.type === "pcb_component" &&
              e.source_component_id ===
                firstComponent.sourceComponent?.source_component_id,
          ) as PcbComponent

          // Find the corresponding pcb_port and its source_port
          const pcbPort = su(circuitElements)
            .pcb_port.list()
            .find((e) => e.pcb_port_id === pad.pcb_port_id)
          const sourcePort = su(circuitElements)
            .source_port.list()
            .find((e) => e.source_port_id === pcbPort?.source_port_id)

          return createPinForImage(pad, pcbComponent, sourcePort)
        })
        .filter((pin): pin is Pin => pin !== undefined),
    }
    pcb.library.images.push(image)

    // Add component entry
    const componentEntry = {
      name: footprintName,
      places: components.map((component) => ({
        refdes: `${component.componentName}_${component.sourceComponent?.source_component_id}`,
        x: component.coordinates.x,
        y: component.coordinates.y,
        side: "front" as const,
        rotation: component.rotation % 90,
        PN: component.value,
      })),
    }
    pcb.placement.components.push(componentEntry)
  }
}
</file>

<file path="process-nets.ts">
import { su } from "@tscircuit/soup-util"
import type { AnyCircuitElement, SourceTrace } from "circuit-json"
import type { DsnPcb } from "../types"

export function processNets(circuitElements: AnyCircuitElement[], pcb: DsnPcb) {
  const componentNameMap = new Map<string, string>()

  for (const element of circuitElements) {
    if (element.type === "source_component") {
      componentNameMap.set(element.source_component_id, element.name)
    }
  }

  const padsBySourcePortId = new Map()

  for (const element of circuitElements) {
    if (
      (element.type === "pcb_smtpad" || element.type === "pcb_plated_hole") &&
      element.pcb_port_id
    ) {
      const pcbPort = su(circuitElements)
        .pcb_port.list()
        .find((e) => e.pcb_port_id === element.pcb_port_id)

      if (pcbPort && "source_port_id" in pcbPort) {
        const sourcePort = su(circuitElements)
          .source_port.list()
          .find((e) => e.source_port_id === pcbPort.source_port_id)

        if (sourcePort && "source_component_id" in sourcePort) {
          const componentName =
            componentNameMap.get(sourcePort.source_component_id) || ""
          const pinNumber = sourcePort.port_hints?.find(
            (hint) => !Number.isNaN(Number(hint)),
          )

          padsBySourcePortId.set(sourcePort.source_port_id, {
            componentName: `${componentName}_${sourcePort.source_component_id}`,
            pinNumber,
            sourcePortId: sourcePort.source_port_id,
          })
        }
      }
    }
  }

  const netMap = new Map()
  const netTraceWidthMap = new Map<string, number>()

  for (const element of circuitElements) {
    if (element.type === "source_trace" && element.connected_source_port_ids) {
      const connectedPorts = element.connected_source_port_ids

      if (connectedPorts.length >= 2) {
        const firstPad = padsBySourcePortId.get(connectedPorts[0])

        if (firstPad) {
          const netName = `Net-(${firstPad.componentName}-Pad${firstPad.pinNumber})`

          if (!netMap.has(netName)) {
            netMap.set(netName, new Set())
          }

          for (const portId of connectedPorts) {
            const padInfo = padsBySourcePortId.get(portId)
            if (padInfo) {
              netMap
                .get(netName)
                ?.add(`${padInfo.componentName}-${padInfo.pinNumber}`)
            }
          }

          // Store trace width if specified
          if ("min_trace_thickness" in element && element.min_trace_thickness) {
            // Convert from mm to μm
            const traceWidthMicrons = element.min_trace_thickness * 1000
            netTraceWidthMap.set(netName, traceWidthMicrons)
          }
        }
      }
    }
  }

  // Only add unconnected nets for pads that aren't part of any existing net
  for (const [sourcePortId, padInfo] of padsBySourcePortId) {
    let isConnected = false
    const padIdentifier = `${padInfo.componentName}-${padInfo.pinNumber.replace("pin", "")}`
    for (const [_, connectedPads] of netMap.entries()) {
      if (
        Array.from(connectedPads).some(
          (pad: unknown) =>
            pad?.toString() === padIdentifier ||
            pad?.toString() === `${padInfo.componentName}-${padInfo.pinNumber}`,
        )
      ) {
        isConnected = true
        break
      }
    }

    // Check if the pad is connected to any source net (GND, VCC)
    let isInSourceNet = false
    for (const element of circuitElements) {
      if (element.type === "source_net") {
        const connectedTraces = circuitElements.filter(
          (e) =>
            e.type === "source_trace" &&
            e.connected_source_net_ids?.includes(element.source_net_id) &&
            e.connected_source_port_ids?.includes(sourcePortId),
        )
        if (connectedTraces.length > 0) {
          isInSourceNet = true

          // Store trace width if specified in any of the connected traces
          for (const trace of connectedTraces) {
            if ("min_trace_thickness" in trace && trace.min_trace_thickness) {
              const traceWidthMicrons = trace.min_trace_thickness * 1000
              netTraceWidthMap.set(
                `${element.name}_${element.source_net_id}`,
                traceWidthMicrons,
              )
              break
            }
          }

          break
        }
      }
    }

    if (!isConnected && !isInSourceNet) {
      const unconnectedNetName = `unconnected-(${padInfo.componentName}-Pad${padInfo.pinNumber.replace("pin", "")})`
      netMap.set(
        unconnectedNetName,
        new Set([`${padInfo.componentName}-${padInfo.pinNumber}`]),
      )
    }
  }

  // Add source nets (GND, VCC, etc.)
  for (const element of circuitElements) {
    if (element.type === "source_net") {
      const netName = `${element.name}_${element.source_net_id}`
      if (!netMap.has(netName)) {
        netMap.set(netName, new Set())
      }
      // Find all traces connected to this net
      const connectedTraces = circuitElements.filter(
        (e) =>
          e.type === "source_trace" &&
          e.connected_source_net_ids?.includes(element.source_net_id),
      ) as SourceTrace[]

      // Add connected ports to the net
      for (const trace of connectedTraces) {
        for (const portId of trace.connected_source_port_ids || []) {
          const padInfo = padsBySourcePortId.get(portId)
          if (padInfo) {
            netMap
              .get(netName)
              ?.add(`${padInfo.componentName}-${padInfo.pinNumber}`)
          }
        }

        // Store trace width if specified
        if (
          "min_trace_thickness" in trace &&
          trace.min_trace_thickness &&
          !netTraceWidthMap.has(netName)
        ) {
          const traceWidthMicrons = trace.min_trace_thickness * 1000
          netTraceWidthMap.set(netName, traceWidthMicrons)
        }
      }
    }
  }

  // Sort nets with source nets first, then connected nets, then unconnected
  const allNets = Array.from(netMap.keys()).sort((a, b) => {
    if (a === "GND") return -1
    if (b === "GND") return 1
    if (a === "VCC") return -1
    if (b === "VCC") return 1
    if (a.startsWith("Net-") && !b.startsWith("Net-")) return -1
    if (!a.startsWith("Net-") && b.startsWith("Net-")) return 1
    return a.localeCompare(b)
  })

  // Create a map of unique trace widths to class names
  const traceWidthClassMap = new Map<number, string>()
  const defaultTraceWidth = 200 // Default width in μm

  // Always include the default class
  traceWidthClassMap.set(defaultTraceWidth, "kicad_default")

  // Create additional classes for each unique trace width
  for (const [netName, traceWidth] of netTraceWidthMap.entries()) {
    if (
      traceWidth !== defaultTraceWidth &&
      !traceWidthClassMap.has(traceWidth)
    ) {
      const className = `trace_width_${traceWidth}um`
      traceWidthClassMap.set(traceWidth, className)

      // Add the new class to pcb.network.classes
      pcb.network.classes.push({
        name: className,
        description: `Trace width ${traceWidth}μm`,
        net_names: [],
        circuit: {
          use_via: "Via[0-1]_600:300_um",
        },
        rule: {
          clearances: [
            {
              value: 200,
              type: "",
            },
          ],
          width: traceWidth,
        },
      })
    }
  }

  // Group nets by trace width class
  const netsByClass = new Map<string, string[]>()

  for (const netName of allNets) {
    const traceWidth = netTraceWidthMap.get(netName) || defaultTraceWidth
    const className = traceWidthClassMap.get(traceWidth) || "kicad_default"

    if (!netsByClass.has(className)) {
      netsByClass.set(className, [])
    }

    netsByClass.get(className)?.push(netName)

    // Add net to pcb.network.nets
    pcb.network.nets.push({
      name: netName,
      pins: Array.from(netMap.get(netName) || []).map((pin) =>
        (pin as string).replace("pin", ""),
      ),
    })
  }

  // Update class net names
  for (const [className, nets] of netsByClass.entries()) {
    const classIndex = pcb.network.classes.findIndex(
      (c) => c.name === className,
    )
    if (classIndex !== -1) {
      pcb.network.classes[classIndex].net_names = nets
    }
  }

  // If a class has no nets, assign it the default net names
  for (const classObj of pcb.network.classes) {
    if (classObj.net_names.length === 0) {
      classObj.net_names = allNets
    }
  }
}
</file>

<file path="process-plated-holes.ts">
import type {
  AnyCircuitElement,
  SourceComponentBase,
  SourcePort,
} from "circuit-json"
import {
  createCircularPadstack,
  createOvalPadstack,
  createCircularHoleRectangularPadstack,
} from "lib/utils/create-padstack"
import { getFootprintName } from "lib/utils/get-footprint-name"
import { getPadstackName } from "lib/utils/get-padstack-name"
import type { ComponentGroup, DsnPcb, Pin, Image } from "../types"
import { getComponentValue } from "lib/utils/get-component-value"
import { applyToPoint, scale } from "transformation-matrix"
import { su } from "@tscircuit/soup-util"

const transformMmToUm = scale(1000)

export function processPlatedHoles(
  componentGroups: ComponentGroup[],
  circuitElements: AnyCircuitElement[],
  pcb: DsnPcb,
) {
  /**
   * Helpers
   */
  const processedPadstacks = new Set<string>()

  /** Guarantee that a padstack for the given plated-hole exists, return its name */
  function ensurePadstack(hole: any): string {
    switch (hole.shape) {
      case "circle": {
        const name = getPadstackName({
          shape: "circle",
          holeDiameter: hole.hole_diameter * 1000,
          outerDiameter: hole.outer_diameter * 1000,
          layer: "all",
        })
        if (!processedPadstacks.has(name)) {
          const d = Math.round(hole.outer_diameter * 1000)
          pcb.library.padstacks.push(createCircularPadstack(name, d, d))
          processedPadstacks.add(name)
        }
        return name
      }
      case "oval":
      case "pill": {
        const name = getPadstackName({
          shape: hole.shape,
          width: hole.hole_width * 1000,
          height: hole.hole_height * 1000,
          layer: "all",
        })
        if (!processedPadstacks.has(name)) {
          const iW = Math.round(hole.hole_width * 1000)
          const iH = Math.round(hole.hole_height * 1000)
          const oW = Math.round(hole.outer_width * 1000)
          const oH = Math.round(hole.outer_height * 1000)
          pcb.library.padstacks.push(createOvalPadstack(name, oW, oH, iW, iH))
          processedPadstacks.add(name)
        }
        return name
      }
      case "circular_hole_with_rect_pad": {
        const name = getPadstackName({
          shape: "rect",
          width: hole.rect_pad_width * 1000,
          height: hole.rect_pad_height * 1000,
          layer: "all",
        })
        if (!processedPadstacks.has(name)) {
          const oW = Math.round(hole.rect_pad_width * 1000)
          const oH = Math.round(hole.rect_pad_height * 1000)
          const hD = Math.round(hole.hole_diameter * 1000)
          pcb.library.padstacks.push(
            createCircularHoleRectangularPadstack(name, oW, oH, hD),
          )
          processedPadstacks.add(name)
        }
        return name
      }
      default:
        throw new Error(`Unsupported plated-hole shape: ${hole.shape}`)
    }
  }

  /** Find or create an Image definition for the given footprint */
  function ensureImage(name: string): Image {
    let image = pcb.library.images.find((img) => img.name === name)
    if (!image) {
      image = { name, outlines: [], pins: [] }
      pcb.library.images.push(image)
    }
    return image
  }

  /** Returns a generator that yields the next unique pin number for the image */
  function createNextPinNumberGenerator(image: Image) {
    let current =
      image.pins.reduce((max, p) => {
        const n = Number(
          typeof p.pin_number === "string"
            ? p.pin_number.replace(/pin/i, "")
            : p.pin_number,
        )
        return Number.isNaN(n) ? max : Math.max(max, n)
      }, 0) + 1
    return () => current++
  }

  function findNumericHint(port?: SourcePort): number | undefined {
    const hint = port?.port_hints?.find((h) => !Number.isNaN(Number(h)))
    return hint !== undefined ? Number(hint) : undefined
  }

  /**
   * MAIN
   */

  const componentsByFootprint = new Map<
    string,
    Array<{
      componentName: string
      coordinates: { x: number; y: number }
      rotation: number
      value: string
      sourceComponent: SourceComponentBase | undefined
    }>
  >()

  for (const group of componentGroups) {
    const { pcb_component_id, pcb_plated_holes, pcb_smtpads } = group
    if (pcb_plated_holes.length === 0) continue

    const pcbComponent = su(circuitElements)
      .pcb_component.list()
      .find((e) => e.pcb_component_id === pcb_component_id)
    if (!pcbComponent) continue

    const sourceComponent = su(circuitElements)
      .source_component.list()
      .find((e) => e.source_component_id === pcbComponent.source_component_id)

    const footprintName = getFootprintName(sourceComponent!, pcbComponent!)
    const image = ensureImage(footprintName)
    const nextPinNumber = createNextPinNumberGenerator(image)

    // Create/update pins for every plated hole
    for (const hole of pcb_plated_holes) {
      const padstackName = ensurePadstack(hole)

      // Resolve sourcePort (if any)
      const pcbPort = hole.pcb_port_id
        ? su(circuitElements)
            .pcb_port.list()
            .find((e) => e.pcb_port_id === hole.pcb_port_id)
        : undefined
      const sourcePort = pcbPort
        ? su(circuitElements)
            .source_port.list()
            .find((e) => e.source_port_id === pcbPort.source_port_id)
        : undefined

      const pinNumber = findNumericHint(sourcePort) ?? nextPinNumber()

      const pin: Pin = {
        padstack_name: padstackName,
        pin_number: pinNumber,
        x: (Number(hole.x.toFixed(3)) - pcbComponent.center.x) * 1000,
        y: (Number(hole.y.toFixed(3)) - pcbComponent.center.y) * 1000,
      }

      // Avoid duplicates
      const duplicate = image.pins.some(
        (p) =>
          p.x === pin.x &&
          p.y === pin.y &&
          p.padstack_name === pin.padstack_name,
      )
      if (!duplicate) image.pins.push(pin)
    }

    // Record components that ONLY have plated holes (no SMT pads) for placement later
    if (pcb_smtpads.length === 0) {
      const key = footprintName
      if (!componentsByFootprint.has(key)) componentsByFootprint.set(key, [])

      componentsByFootprint.get(key)!.push({
        componentName: sourceComponent?.name || "Unknown",
        coordinates: applyToPoint(transformMmToUm, pcbComponent.center),
        rotation: pcbComponent.rotation || 0,
        value: getComponentValue(sourceComponent),
        sourceComponent,
      })
    }
  }

  // Emit placement data for plated-hole-only footprints
  for (const [footprint, comps] of componentsByFootprint) {
    pcb.placement.components.push({
      name: footprint,
      places: comps.map((c) => ({
        refdes: `${c.componentName}_${c.sourceComponent?.source_component_id}`,
        x: c.coordinates.x,
        y: c.coordinates.y,
        side: "front" as const,
        rotation: c.rotation % 90,
        PN: c.value,
      })),
    })
  }
}
</file>

<file path="stringify-dsn-json.ts">
import type { DsnPcb } from "../types"

export const stringifyDsnJson = (dsnJson: DsnPcb): string => {
  const indent = "  "
  let result = ""

  // Helper function to stringify a value with proper formatting
  const stringifyValue = (value: any): string => {
    if (value === null || value === undefined) {
      return '""'
    }
    if (typeof value === "string") {
      return `"${value}"`
    }
    return value.toString()
  }

  // Helper function to stringify an array of coordinates
  const stringifyCoordinates = (coordinates: number[]): string => {
    return coordinates.join(" ")
  }

  // Helper function to stringify a path
  const stringifyPath = (path: any, level: number): string => {
    const padding = indent.repeat(level)
    return `${padding}(path ${path.layer} ${path.width}  ${stringifyCoordinates(path.coordinates)})`
  }

  // Start with pcb
  result += `(pcb ${dsnJson.filename ? dsnJson.filename : "./converted_dsn.dsn"}\n`

  // Parser section
  result += `${indent}(parser\n`
  result += `${indent}${indent}(string_quote ")\n`
  result += `${indent}${indent}(space_in_quoted_tokens on)\n`
  result += `${indent}${indent}(host_cad "KiCad's Pcbnew")\n`
  result += `${indent}${indent}(host_version "${dsnJson.parser.host_version}")\n`
  result += `${indent})\n`

  // Resolution and unit
  result += `${indent}(resolution ${dsnJson.resolution.unit} ${dsnJson.resolution.value})\n`
  result += `${indent}(unit ${dsnJson.unit})\n`

  // Structure section
  result += `${indent}(structure\n`
  dsnJson.structure.layers.forEach((layer) => {
    result += `${indent}${indent}(layer ${layer.name}\n`
    result += `${indent}${indent}${indent}(type ${layer.type})\n`
    result += `${indent}${indent}${indent}(property\n`
    result += `${indent}${indent}${indent}${indent}(index ${layer.property.index})\n`
    result += `${indent}${indent}${indent})\n`
    result += `${indent}${indent})\n`
  })
  if (dsnJson.structure.boundary) {
    result += `${indent}${indent}(boundary\n`
    result += `${indent}${indent}${indent}${stringifyPath(dsnJson.structure.boundary.path, 0)}\n`
    result += `${indent}${indent})\n`
  }
  result += `${indent}${indent}(via ${stringifyValue(dsnJson.structure.via)})\n`
  result += `${indent}${indent}(rule\n`
  result += `${indent}${indent}${indent}(width ${dsnJson.structure.rule.width})\n`
  dsnJson.structure.rule.clearances.forEach((clearance) => {
    result += `${indent}${indent}${indent}(clearance ${clearance.value}${clearance.type ? ` (type ${clearance.type})` : ""})\n`
  })
  result += `${indent}${indent})\n`
  result += `${indent})\n`

  // Placement section
  result += `${indent}(placement\n`
  dsnJson.placement.components.forEach((component) => {
    result += `${indent}${indent}(component ${stringifyValue(component.name)}\n`
    if (component.places) {
      component.places.forEach((place) => {
        result += `${indent}${indent}${indent}(place ${place.refdes} ${place.x} ${place.y} ${place.side} ${place.rotation}${place.PN ? ` (PN ${stringifyValue(place.PN)})` : ""})\n`
      })
    }
    result += `${indent}${indent})\n`
  })
  result += `${indent})\n`

  // Library section
  result += `${indent}(library\n`
  dsnJson.library.images.forEach((image) => {
    result += `${indent}${indent}(image ${stringifyValue(image.name)}\n`
    image.outlines.forEach((outline) => {
      result += `${indent}${indent}${indent}(outline ${stringifyPath(outline.path, 4)})\n`
    })
    image.pins.forEach((pin) => {
      result += `${indent}${indent}${indent}(pin ${pin.padstack_name} ${pin.pin_number} ${pin.x} ${pin.y})\n`
    })
    result += `${indent}${indent})\n`
  })
  dsnJson.library.padstacks.forEach((padstack) => {
    result += `${indent}${indent}(padstack ${stringifyValue(padstack.name)}\n`
    padstack.shapes.forEach((shape) => {
      if (shape.shapeType === "polygon") {
        result += `${indent}${indent}${indent}(shape (polygon ${shape.layer} ${shape.width} ${stringifyCoordinates(shape.coordinates)}))\n`
      } else if (shape.shapeType === "circle") {
        result += `${indent}${indent}${indent}(shape (circle ${shape.layer} ${shape.diameter}))\n`
      } else if (shape.shapeType === "path") {
        result += `${indent}${indent}${indent}(shape (path ${shape.layer} ${shape.width} ${stringifyCoordinates(shape.coordinates)}))\n`
      }
    })
    result += `${indent}${indent}${indent}(attach ${padstack.attach})\n`
    result += `${indent}${indent})\n`
  })
  result += `${indent})\n`

  // Network section
  result += `${indent}(network\n`
  dsnJson.network.nets.forEach((net) => {
    result += `${indent}${indent}(net ${stringifyValue(net.name)}\n`
    if (net.pins.length > 0) {
      result += `${indent}${indent}${indent}(pins ${net.pins.join(" ")})\n`
    }
    result += `${indent}${indent})\n`
  })
  dsnJson.network.classes.forEach((cls) => {
    result += `${indent}${indent}(class ${stringifyValue(cls.name)} ${stringifyValue(cls.description)}${cls.net_names.map((n) => ` ${stringifyValue(n)}`).join("")}\n`
    result += `${indent}${indent}${indent}(circuit\n`
    result += `${indent}${indent}${indent}${indent}(use_via ${stringifyValue(cls.circuit.use_via)})\n`
    result += `${indent}${indent}${indent})\n`
    if (cls.rule) {
      result += `${indent}${indent}${indent}(rule\n`
      result += `${indent}${indent}${indent}${indent}(width ${cls.rule.width})\n`
      cls.rule.clearances.forEach((clearance) => {
        result += `${indent}${indent}${indent}${indent}(clearance ${clearance.value}${clearance.type ? ` (type ${clearance.type})` : ""})\n`
      })
      result += `${indent}${indent}${indent})\n`
    }
    result += `${indent}${indent})\n`
  })
  result += `${indent})\n`

  // Wiring section
  result += `${indent}(wiring\n`
  ;(dsnJson.wiring?.wires ?? []).forEach((wire) => {
    if (wire.type === "via") {
      result += `${indent}${indent}(via ${stringifyPath(wire.path, 3)}(net ${stringifyValue(wire.net)}))\n`
    } else {
      result += `${indent}${indent}(wire ${stringifyPath(wire.path, 3)}(net ${stringifyValue(wire.net)})(type ${wire.type}))\n`
    }
  })
  result += `${indent})\n`

  // Close pcb
  result += `)\n`

  return result
}
</file>

<file path="stringify-dsn-session.ts">
import type { DsnSession } from "../types"

export const stringifyDsnSession = (session: DsnSession): string => {
  const indent = "  "
  let result = ""

  // Start with session
  result += `(session ${session.filename}\n`

  // Base design
  result += `${indent}(base_design ${session.filename})\n`

  // Placement section
  result += `${indent}(placement\n`
  result += `${indent}${indent}(resolution ${session.placement.resolution.unit} ${session.placement.resolution.value})\n`
  session.placement.components.forEach((component) => {
    result += `${indent}${indent}(component ${component.name}\n`
    component.places.forEach((place) => {
      result += `${indent}${indent}${indent}(place ${place.refdes} ${place.x} ${place.y} ${place.side} ${place.rotation})\n`
    })
    result += `${indent}${indent})\n`
  })
  result += `${indent})\n`

  // Was_is section (if needed)
  result += `${indent}(was_is\n${indent})\n`

  // Routes section
  result += `${indent}(routes \n`
  result += `${indent}${indent}(resolution ${session.routes.resolution.unit} ${session.routes.resolution.value})\n`

  // Parser subsection
  result += `${indent}${indent}(parser\n`
  result += `${indent}${indent}${indent}(host_cad ${JSON.stringify(session.routes.parser.host_cad)})\n`
  result += `${indent}${indent}${indent}(host_version ${JSON.stringify(session.routes.parser.host_version)})\n`
  result += `${indent}${indent})\n`

  // Library_out subsection
  if (session.routes.library_out) {
    result += `${indent}${indent}(library_out \n`
    session.routes.library_out.padstacks.forEach((padstack) => {
      result += `${indent}${indent}${indent}(padstack ${JSON.stringify(padstack.name)}\n`
      padstack.shapes.forEach((shape) => {
        if (shape.shapeType === "circle") {
          result += `${indent}${indent}${indent}${indent}(shape\n`
          result += `${indent}${indent}${indent}${indent}${indent}(circle ${shape.layer} ${shape.diameter} 0 0)\n`
          result += `${indent}${indent}${indent}${indent})\n`
        }
      })
      result += `${indent}${indent}${indent}${indent}(attach ${padstack.attach})\n`
      result += `${indent}${indent}${indent})\n`
    })
    result += `${indent}${indent})\n`
  }

  // Network_out subsection
  result += `${indent}${indent}(network_out \n`
  session.routes.network_out.nets.forEach((net) => {
    result += `${indent}${indent}${indent}(net ${JSON.stringify(net.name)}\n`
    net.wires.forEach((wire) => {
      if (wire.path) {
        result += `${indent}${indent}${indent}${indent}(wire\n`
        result += `${indent}${indent}${indent}${indent}${indent}(path ${wire.path.layer} ${wire.path.width}\n`
        result += `${indent}${indent}${indent}${indent}${indent}${indent}${wire.path.coordinates.join(" ")}\n`
        result += `${indent}${indent}${indent}${indent}${indent})\n`
        result += `${indent}${indent}${indent}${indent})\n`
      }
    })
    result += `${indent}${indent}${indent})\n`
  })
  result += `${indent}${indent})\n`

  result += `${indent})\n`

  // Close session
  result += `)\n`

  return result
}
</file>

</files>
